# 12. 함수

## 12.1 함수란?

- **수학**의 함수 ⇒ 입력을 받아 출력을 내보내는 일련의 과정을 정의한 것, 프로그래밍 언어의 함수도 같은 개념.
- **프로그래밍 언어**의 **함수** ⇒ **일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행단위로 정의**한 것.
  - 전달받는 변수 : **매개변수**(parameter)
  - 입력 : **인수**(argument)
  - 출력 : **반환값**(return value)

![image](https://user-images.githubusercontent.com/46212602/175057901-e32b96ef-0759-4eb3-9f1f-4b78cd3480a8.png)

- 함수는 **함수 정의**를 통해서 생성되며 다양한 방법으로 정의 가능.

```jsx
// 함수 선언문을 통해 함수 정의
function add(x, y) {
  return x + y;
}
```

- 인수를 매개변수를 통해 함수에 전달하면 **함수 호출**이 되면서 **코드블록에 담긴 문들이 일괄적으로 실행**됨.

## 12.2 함수를 사용하는 이유

- 필요할 때 호출 할 수 있으므로 **코드의 재사용성**에서 유용하다.
- 또한 **코드 중복을 억제**하고 **재사용성**을 높여 **유지보수의 편의성**을 높이고 실수를 줄여 **코드의 신뢰성**을 높이는 효과를 준다.
- 함수는 객체 타입의 값이므로 식별자를 붙일 수 있는데 함수 이름을 잘 설명해야 **코드의 가독성을 향상**시킨다.
- 코드는 개발자를 위한 문서이므로 사람이 이해할 수 있는 코드, 즉 **가독성이 좋은 코드가 좋은 코드**이다.

## 12.3 함수 리터럴

```jsx
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```

**함수 리터럴의 구성요소**

| 구성요소  | 설명                                                               |
| --------- | ------------------------------------------------------------------ |
| 함수 이름 | - 함수 이름은 식별자다. 따라서 식별자 네이밍 규칙을 준수해야 한다. |

- 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.

- 함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 무명/익명 함수라 한다. |
  | 매개변수 목록 | - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.

- 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당된다. 즉, 매개변수 목록은 순서에 의미가 있다.

- 매개 변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다. |
  | 함수 몸체 | - 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.

- 함수 몸체는 함수 호출에 의해 실행된다. |
- 함수 리터럴을 변수에 할당하고 있으며 함수 리터럴도 평가되어 값(객체)을 생성한다. ⇒ 함수는 객체!
- 함수는 객체이지만 일반객체와 다르게 호출이 가능하다. (일반 객체는 호출이 불가능하다.)
- 함수가 객체라는 사실은 다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징이다.

## 12.4 함수 정의

- 함수를 정의하는 4가지 방식

| 함수 정의 방식 | 예시                 |
| -------------- | -------------------- |
| 함수 선언문    | function add (x,y) { |

return x + y;
} |
| 함수 표현식 | var add = function (x, y) {
return x+y;
} |
| Function 생성자 함수 | var add = new Function (’x’, ‘y’, ‘return x+y’); |
| 화살표 함수(ES6) | var add = ( x, y ) ⇒ x + y; |

**변수 선언과 함수 정의**

- 변수는 **선언(declaration)**, 함수는 **정의(definition)**으로 표현한다.
- **ECMAScript** 사양에서도 변수에는 선언, 함수는 정의로 표현한다.

### **12.4.1 함수 선언문**

```jsx
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 참조, 매개변수로 전달된 객체의 속성을 출력한다
// JSON과 같은 트리 구조로 출력 하고, DOM JS 객체의 전체 표현을 보려고 할 때 유용하다.
console.dir(add); // f add(x,y)

// 함수 호출, 매개변수로 전달된 값을 출력한다.
// HTML과 같은 트리 구조로 출력한다.
console.log(add(2, 5)); // 7
```

- 함수 선언문은 **함수 이름을 생략할 수 없다**.
- 함수 선언문은 **표현식이 아닌 문**이다. ⇒ 완료값으로 **undefined** 출력됨.

```jsx
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.
//
var add = function add(x, y) {
  return x + y;
};
// 함수 호출
console.log(add(2, 5)); // 7
```

- **함수 선언문**이 표현식이 아니지만 **변수에 할당**되는 것 처럼 보임.
- 자바스크립트 엔진이 코드 문맥에 따라 함수 선언식이 아닌 **함수 리터럴 표현식**으로 해석하는 경우가 있다. ⇒ 함수 리터럴과 함수 선언문은 함수 이름을 생략할 수 없다는 점만 제외하고 동일함. ⇒ 코드 문맥에 따라 해석이 달라질 수 있다.
- **단독으로 사용하면 함수 선언문으로 해석**되고, **변수에 할당**하거나 **피연산자로 사용**하면 **함수 리터럴 표현식으로 해석**한다.

```jsx
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() {
  console.log('foo');
}
foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석한다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() {
  console.log('bar');
});
bar(); // ReferenceError: bar is not defined
```

- 그룹 연산자 `()` 내에 있는 함수 리터럴은 함수 선언문으로 해석되지 않고 **함수 리터럴 표현식**으로 해석된다.
- 그룹 연산자의 피연산자는 값으로 평가될 수 있는 표현식이여야 한다. ⇒ 표현식이 아닌 함수 선언문은 피연산자로 사용할 수 없다.

![image](https://user-images.githubusercontent.com/46212602/175058018-bbf1001c-a92d-460f-9e47-7138474ee84a.png)

- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 **동일한 이름의 식별자를 암묵적으로 생성**하고, 거기에 함수 객체를 할당한다.
- 함수 선언문을 **의사 코드로 표현**하면 다음과 같다.

```jsx
var add = function add(x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```

- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가르키는 식별자로 호출한다.
- 함수 선언문으로 생성한 함수를 호출하는 것은 함수 이름이 아닌 자바스크립트 엔진이 암묵적으로 생성한 식별자를 호출한다.(함수이름과 식별자가 일치함.)

![image](https://user-images.githubusercontent.com/46212602/175058105-3e2fce80-0779-4e03-9199-0e41d806da3c.png)

### **12.4.2 함수 표현식**

- 자바스크립트의 함수는 **일급 객체**이다.
- 일급 객체는 **값처럼 변수에 할당**할 수 있고, **프로퍼티 값**이 될수도 있으며, **배열의 요소**도 될 수 있다.
- 이러한 함수의 정의 방식을 **함수 표현식(function expression)** 이라 한다.

```jsx
// 함수 표현식
var add = function (x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```

- 함수 리터럴의 함수 이름은 생략할 수 있다. 이러한 함수를 **익명 함수**라 한다.
- 함수 표현식의 함수 리터럴은 **함수 이름을 생략하는 것이 일반적**이다.

```jsx
// 기명 함수 표현식
var add = function foo(x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7

// 함수 이름으로 호출하면 ReferenceError가 발생한다.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.
console.log(foo(2, 5)); // ReferenceError: foo is not defined
```

- 함수 선언문은 표현식이 아닌 문이고, 함수 표현식은 표현식인 문이다.

### 12.4.3 함수 생성 시점과 함수 호이스팅

```jsx
// 함수 참조
console.dir(add); // ƒ add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.
- 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.
- **함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다.**

- 함수 선언문은 런타임 이전에 함수 객체가 먼저 생성된다. 그리고 함수 이름과 동일한 이름으로 식별자를 생성하고 생성된 함수 객체를 할당한다.
- 즉, 코드가 실행되는 런타임시점에는 이미 함수 객체가 생성되어 있고 식별자에 할당까지 완료된 상태이다.
- 따라서 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하며 이를 **함수 호이스팅(function hoisting)**이라고 한다.

**함수 선언문** ⇒ **코드(함수 선언문을 포함한) 평가 단계**에서 함수 객체 생성.

**함수 표현식** ⇒ **코드(함수 표현식을 포함한) 실행 단계**에서 함수 객체 생성.

### 함수 호이스팅 vs 변수 호이스팅

- var키워드를 사용한 변수 선언문과 함수 선언문은 런타임 이전에 **엔진에 의해** **먼저 실행되어 식별자를 생성하는 점은 동일**하다.
- 하지만, var키워드로 선언된 변수는 **undefined로 초기화**되고, 함수 선언문은 **함수 객체로 초기화** 된다.
- 따라서, var키워드를 사용한 변수는 선언문 이전에 참조하면 **undefined로 평가**되지만, 함수 선언문은 함수 호이스팅에 의해 **호출이 가능**하다.

### 함수 표현식

- 함수 표현식은 변수에 할당되는 값이 **함수 리터럴**. 즉, **문**이다.
- 따라서 **변수 선언문과 할당문**을 한번에 기술한 표현과 **동일하게 동작**한다.
- 변수 선언은 런타임 이전에 실행되어 **undefined로 초기화** 되고, 변수 할당문이 실행되는 시점, 즉 **런타임 시점**에 함수 표현식의 함수 리터럴이 평가되어 함수 객체가 **변수 할당문의 값이 되어 할당**된다.
- 결과적으로 **함수 표현식**은 함수 호이스팅이 발생되지 않고 **변수 호이스팅**만 **발생**된다.
- 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 규칙을 무시하기 때문에 **함수 선언문 보다는 함수 표현식의 사용을 권장한다.**

### 12.4.4 Function 생성자 함수

- new 연산자와 함꼐 호출하면서 함수 객체를 생성해서 반환한다.(new 연산자 없이 호출해도 결과는 동일하다.)
  **생성자 함수**
  - 객체를 생성하는 함수를 말한다. (17장에 이어서)

```jsx
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
```

- Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.
- 클로저(closure)를 생성하지 않는 등 함수 선언문과 함수 표현식과는 다르게 동작한다.

```jsx
var add1 = (function () {
  var a = 10;
  return function (x, y) {
    return x + y + a;
  };
})();

console.log(add1(1, 2)); // 13

var add2 = (function () {
  var a = 10;
  return new Function('x', 'y', 'return x + y + a;'); // 클로저 환경이 만들어지지 않아 a(자유변수)를 참조할 수 없다.
})();

console.log(add2(1, 2)); // ReferenceError: a is not defined
```

### 12.4.5 화살표 함수

- ES6에서 도입된 화살표 함수는 function 키워드 대신에 화살표(⇒)를 사용해 좀 더 간결하게 사용 가능.
- 항상 익명 함수로 정의한다.

```jsx
// 화살표 함수
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

- 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화되어 있다.
- 생성자 함수로 사용할 수 없으며 기존함수와 this 바인딩 방식이 다르고 prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다. (26.3절에서 설명됨.)

  12.5 함수 호출

  12.6 참조에 의한 전달과 외부 상태의 변경

  12.7 다양한 함수의 형태
