# 05. 표현식과 문

## 5.1 값

- **값(value)**이란, **식(표현식, expression)**이 **평가(evaluate)**되어 생성된 결과를 말한다.
- `10 + 20` 이 평가되어 **값** `30`을 생성한다.
- 모든 값은 데이터 타입을 가지고, 메모리에 비트(2진수)의 나열로 저장된다.
- 저장된 값은 데이터 타입에 따라 다르게 해석 할 수 있다.
  - `0100 0001` 를 숫자로 ⇒ `65`
  - `0100 0001` 를 문자로 ⇒ ‘`A`’
- `var sum = 10 + 20;`⇒ sum 변수에 30이 할당된다.
- 값을 생성하는 가장 기본적인 방법 ⇒ **리터럴 사용**

## 5.2 리터럴

- 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법 : **리터럴(literal)**
- 여러 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등 )또는 미리 약속된 기호(`””`, `.`, `[]`, `{}`, `//` 등)로 표기한 코드
- 자바스크립트 엔진은 코드가 실행되는 시점(런타임)에 리터럴을 평가해 값을 생성한다.
- **리터럴** ⇒ 값을 생성하기 위한 약속된 표기법

![05-1](https://user-images.githubusercontent.com/46212602/174198396-970b09b4-db59-485d-8b58-3f694e0db5dc.png)

## 5.3 표현식

- **표현식(expression)** : **값으로 평가될 수 있는 문**(statement)으로, 표현식이 **평가**되면 **새로운 값을 생성**하거나 **기존값을 참조**함.
- 리터럴도 값으로 평가할 수 있어 리터럴도 표현식이다.

```jsx
var score1 = 100; // 100 => 표현식

var score2 = 50 + 50; // 50+50 평가되어 표현식

score2; // 값을 생성하지는 않지만 값으로 평가, 표현식
```

- 값으로 평가될 수 있는 것은 모두 표현식이다.

```jsx
// 리터럴 표현식
10;
('hello');

//식별자 표현식
sum;
person.name;
arr[1];

//연산자 표현식
10 + 20;
sum = 10;
sum !== 10;

// 함수/메서드 호출 표현식
square();
person.getName();
```

- 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어 낼 수 있어야함.

## 5.4 문

- **문(statement)** : 프로그램을 구성하는 기본 단위이자 최소 실행 단위로 여러 토큰으로 구성됨. EX) 선언문, 할당문, 조건문, 반복문…
  - 문의 집합 ⇒ 프로그램
  - 문을 작성하고 순서에 맞게 나열하는 것 ⇒ 프로그래밍
- **토큰** : 문법적인 의미를 지니며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소
  - `var` `sum` `=` `1` `+` `2` `;`
- 문은 명령문이라고도 부름. ⇒ 컴퓨터에 내리는 명령.
- 문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

```jsx
// 변수 선언문
var x;

// 할당문
x = 5;

// 함수 선언문
function foo() {}

// 조건문
if (x > 1) {
  console.log(x);
}

// 반복문
for (var i = 0; i < 2; i++) {
  console.log(i);
}
```

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

- 세미콜론(;)은 문의 종료를 나타낸다.
- 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다.
- 단, if문, for문, 함수 등 코드 블록 뒤에는 세미콜론을 붙이지 않음 ⇒ 자체 종결성을 가지기 때문이다.
- 자바스크립트 엔진이 소스코드르 해석할 때 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI)이 수행됨. ⇒ 세미콜론은 옵션!
- ESLint는 세미콜론 사용을 기본으로 설정되어 있고, TC39(ECMAScript 기술 위원회)도 세미콜론 사용을 권장하는 분위기이다.

```jsx
function foo() {
  return;
  {
  }
  // ASI 의 동작 결과 => return; {};
  // 개발자의 예측 => return {};
}

console.log(foo()); // undefined;

var bar = (function () {})(function () {})();
// ASI의 동작결과 => var bar = function (){} (function() {})();
// 개발자의 예측 => var bar = function (){}; (function() {})();
```

![05-2](https://user-images.githubusercontent.com/46212602/174198466-5aa193a1-9d08-4a15-a917-cd6abf679653.png)

## 5.6 표현식인 문과 표현식이 아닌 문

```jsx
// 변수 선언문, 값으로 평가 불가함 - 표현식이 아닌 문
var x;

//값으로 평가됨 - 표현식인 문
x = 1 + 2;
```

- 표현식인 문과 표현식이 아닌문을 구별하는 법 ⇒ 변수를 할당해보기

```jsx
//표현식이 아닌 문은 값처럼 사용 불가
var foo = var x;

// 표현식인 문은 값처럼 사용할 수 있다.
var foo = x = 100;
```

### 완료값

- 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하는데, 이를 완료값이라고 하며 완료값은 평가 결과가 아니다.

![05-3](https://user-images.githubusercontent.com/46212602/174198470-56e1a6b1-dd4b-40a0-b171-98d89e0b9e9b.png)

- 표현식인 문을 실행하면 언제나 평가된 값을 반환한다.

![05-4](https://user-images.githubusercontent.com/46212602/174198472-b82f419d-8bfd-4528-a0d0-80b858734b48.png)
